#import "./lib.typ": *
#show: thmrules

#show: title.with(
  title: "数字逻辑整理",
  date: "2025-12-02",
  name: "潜伏",
)

= 数制与编码

== 有权码
- 5421BCD码：就是用四位10数表示0-9，5421是每一位对应的权重,因为是表示0-9，所以1110以后的码都是无效码
- 8421BCD码：就是用四位10数表示0-9，8421是每一位对应的权重,因为是表示0-9，所以1010以后的码都是无效码
== 无权码
- 余三码：就是把十位进制下的数每一个加三，然后转换成对应的二进制代码/余三码=8421码+0011，例如 $73=>(10)(6)=>(1010)(0110)$
- 格雷码：格雷码转换二进制代码是把最高位保留，然后拿最高位与次位异或，异或的结果作为次位，同时结果再和下一位异或

== 反函数与对偶函数

- 反函数：直接把表达式取反即可
- 对偶函数：将表达式中的与运算替换为或运算，或运算替换为与运算
  - 不能改变运算顺序，$F= A B+C=>F^'=(A+B) dot C$
  - 长非号下的算式，长非号不动，直接变换或与即可， $F= overline(A B) => F^'=overline(A+B)$


== 进制转换

- b <=> h  四位二进制代码对应一位十六进制代码，前方不足补0，将位数补齐到被4整除
- b <=> o  三位二进制代码对应一位八进制代码，前方不足补0，将位数补齐到被3整除

= 布尔代数

== 最小项和最大项

- 最小项：在n变量的布尔函数中，包含n个变量且每个变量只出现一次的与项叫做该函数的一个最小项，记作 $m_i$ ，其中i为该最小项所对应的二进制数转换成的十进制数。同时，最小项的代号中，A表示 '1'，$overline(A)$表示 '0'，例如 $m_5= A overline{B} C =101$
- 最大项：在n变量的布尔函数中，包含n个变量且每个变量只出现一次的或项叫做该函数的一个最大项，记作 $M_i$ ，其中i为该最大项所对应的二进制数转换成的十进制数。同时，最大项的代号中，A表示 '0'，$overline(A)$表示 '1'，例如 $M_5= overline(A) + B + overline{C} =010$

== 公式化简

记住几个化简主要公式即可：

- $A + A B = A$，$A (A + B) = A$
- $A + B C = (A + B)(A + C)$，$A (B + C) = A B + A C$
- $A B + overline(A)C + B C =A B + overline(A)C$
- $B overline(C) + overline(B)C = B xor C space B C + overline(B)space overline(C)= B ⊙ C$

== 布尔代数的应用

- 逻辑函数的标准形式：将逻辑函数表示为所有变量的最小项之和（SOP）或最大项之积（POS）的形式
- 逻辑函数的化简：通过应用布尔代数定律和定理，简化逻辑函数以减少所需的逻辑门数量
- 逻辑电路的设计：使用布尔代数来设计和分析组合逻辑电路

= 卡诺图

== 化简口诀

- 画图：根据函数的真值表或最小项/最大项列表绘制卡诺图
- 包圈：将相邻的1进行包圈，画成的圈只能有 $2^n$ 个 1 ，同时形成尽可能大的矩形区域，其中化简的时候要注意 “穿墙” 状态，和四个角也可以形成一个圈
- 相同的保留，不同的消去，例如 AB 对应两个标号 "11" 和 "10",化简出来B被消去，A保留为正，如此写出化简表达式



= 组合电路

== 多路选择器和译码器

- 多路选择器： 根据选择输入的值，从多个数据输入中选择一个数据输出。例如，4-1多路选择器有4个数据输入、2个选择输入和1个数据输出。
- 3-8译码器： 将3位二进制输入转换为8个输出中的一个。例如，输入000时，输出$Y_0$为高电平，其他输出为低电平，输入010时，输出$Y_2$为高电平，其他输出为低电平。

== 编码器

- 普通编码器： 作用与译码器相反，将多个输入信号编码为较少的输出信号。例如，8-3编码器有8个输入和3个输出，当某个输入为高电平时，输出对应的二进制代码。
- 优先编码器： 普通编码器不能接受多个输入同时为高电平的情况，而优先编码器可以处理这种情况，并且输出最高优先级的输入对应的二进制代码。

== 组合元器件的 verilog 实现

= 时序逻辑元件

== 锁存器

锁存器是根据电平触发， 即当使能信号为高电平时，锁存器的状态可以改变；当使能信号为低电平时，锁存器保持其当前状态。所以在一个周期内会产生多次变化，即空翻现象。
- SR锁存器： 次态方程 $Q_(n+1) = S + overline(R) Q_n (S R=0 "约束条件")$

== 边沿触发器


- 边沿SR触发器 $Q_(n+1) = S + overline(R) Q_n , space S R=0$
- 边沿D触发器 $Q_(n+1) = D$
- 边沿JK触发器 $Q_(n+1) = J overline(Q_n) + overline(K) Q_n$
- T触发器 $Q_(n+1) = T xor Q_n$
- T'触发器 $Q_(n+1) = overline(T) xor Q_n$



== 寄存器

- 基本寄存器 : 用于存储数据的基本单元，通常由多个触发器组成，每个触发器存储一位数据。
- 移位寄存器 : 能够将数据按位移动的寄存器，可以实现数据的串行输入和输出。


== 计数器

- 环形计数器：每次把移位寄存器最后一位的输出反馈到第一位上，一共只有 n 个状态
- 扭环形计数器 ：将移位寄存器最后一位取反后输出到第一位输入端，一共有 2n 个状态

= 时序电路设计

== 设计方案

1. 状态转换图和初始状态表
2. 状态化简 相同输入下，现态和次态均相同的状态可以合并
3. 状态分配（有三个经验法则）
  1. 相同次态对应的现态应该给相同编码
  2. 同一现态在不同输入下对应的次态应该给予相同编码
  3. 给定输入下，输出完全相同，现态编码应该相邻
4. 真值表
5. 画出卡诺图化简
6. 说明是否可以自启动


= 中规模芯片设计时序电路

== 常用芯片

下面这两种芯片的主要功能差异时间控制方式不同，前者是异步清零，后者是同步清零，会在清零法上面存在差别。

=== 74LS160/161

4 位同步计数器，具有异步清零 `CLR_n`、同步并行置数 `LOAD_n`，使能端 `ENP, ENT`。

#figure(
  align(center)[
    #table(
      columns: (5em, 5em, 3em, 3em, 14em),
      align: left + horizon,
      stroke: none,
      table.header([$C L R_n$], [$L O A D_n$], [$E N P$], [$E N T$], [功能]),
      [0], [X], [X], [X], [异步清零，$Q_3 Q_2 Q_1 Q_0 <== 0000$ （与时钟无关）],
      [1], [0], [X], [X], [下一个时钟上升沿并行置数：$Q <== D_3 D_2 D_1 D_0$],
      [1], [1], [1], [1], [下一个时钟上升沿加 1：160 为十进制计数 0~9 循环，161 为二进制计数 0~15 循环],
      [1], [1], [0], [X], [保持不变],
      [1], [1], [X], [0], [保持不变],
    )
  ],
  caption: "74LS160/161 功能表",
)

=== 74LS162/163


#figure(
  align(center)[
    #table(
      columns: (5em, 5em, 3em, 3em, 14em),
      align: left + horizon,
      stroke: none,
      table.header([$C L R_n$], [$L O A D_n$], [$E N P$], [$E N T$], [在时钟上升沿的功能]),
      [1], [0], [X], [X], [$Q <== D_3 D_2 D_1 D_0$（优先级最高）],
      [0], [1], [X], [X], [$Q_3 Q_2 Q_1 Q_0 <== 0000$],
      [1], [1], [1], [1], [162 为十进制计数 ，163 为十六进制计数],
      [1], [1], [0], [X], [保持不变],
      [1], [1], [X], [0], [保持不变],
    )
  ],
  caption: "74LS162/163 功能表",
)

=== 置数法与清零法

清零法有两种方式：
- 异步清零法：通过异步清零端口将计数器清零，无需等待时钟沿，即可清零，设计 M 计数器时，需要 M+1 个状态 第M+1个状态会短暂存在，
- 同步清零法：通过同步清零端口将计数器清零，满足清零条件后还需要等待时钟沿才可以触发清零，设计 M 计数器时，需要 M 个状态



== 序列信号发生器的设计

=== D 触发器设计

例如 110100 序列信号发生器的设计：

画出 状态转换图 $S_0 space Y=1 -> S_1 space Y=1 -> S_2 space Y=0 -> S_3 space Y=1 -> S_4 space Y=0 -> S_5 space Y=0 -> S_0 space Y=1$

Moore 状态图，就可以列出 D 触发器关于 $Q_2Q_1Q_0$ 的真值表

=== 计数器+数据选择器

例如设计110100序列信号发生器：

将计数器设置为 6 进制计数器，数据选择器的 $I_0I_1I_2I_3I_4I_5=110100$,将选择器的输入选择信号连接到 $Q_A Q_B Q_C$,$Q_A Q_B Q_C$变化的时候就会输出序列。



= 555定时器

== 功能与状态表

#figure(
  align(center)[
    #table(
      columns: (3em, 4em, 4em, 3em, 3em),
      align: left + horizon,
      stroke: none,
      [$R'_D$], [$V_(I_1)$], [$V_(I_2)$], [$V_o$], [$T_D$],
      [0], [X], [X], [0], [导通],
      [1], [$>2/3 V_(c c)$] ,  [$> 1/3 V_(c c)$], [0], [导通],
      [1], [$< 2/3 V_(c c)$], [$> 1/3 V_(c c)$], [不变], [不变],
      [1], [$< 1/3 V_(c c)$], [$< 1/3 V_(c c)$], [1], [截止],
      [1], [$> 1/3 V_(c c)$], [$< 1/3 V_(c c)$], [1], [截止],
    )
  ],
  caption: "555 定时器功能表",
)

**口诀**： 都大为0，都下为1，一小一大是保持


== 周期的计算
脉冲周期 $T= T_1 + T_2$

占空比=$T_1 / T_2$

$T_1 = (R_1 +R_2)C ln((V_(c c)- V_(T^-))/(V_(c c)- V_(T^+))) \ T_2 =R_2 C ln((0- V_(T^+))/(0- V_(T^-)))$

在5脚没有外界电压 $V_(C O)$ 的情况下 ，$V_(T^+)= 2/3 V_(c c), space V_(T^-)= 1/3 V_(c c)$,如果接了外界电压 $V_(C O)$ 则 $V_(T^+)= V_(C O ) space V_(T^-) = 1/2 V_(C O) $.